一個DSL合理的定義是其script格式都是由人可以方便閱讀或編寫的，它們可從 script中讀取“輸入”、“控制”或“配置文件”，這些資訊[22]。MasonPy的DSL指令 設計是參考Verilog的指令，衍生而來，如Verilog指令 xor  xor1( W1, A, B );這行代表是 我有一名稱為xor1的元件，它是xor的模組，W1為輸出，A、B為輸入。 MasonPy的DSL指令格式是由List表達，一個功能塊的List格式為[功能塊名稱+編號， 匯入的模組，輸入線list，輸出線List，其他附加條件]，如表4.2.3，由List可得知其為哪 種功能塊、用哪種模組、有哪些輸入線、哪些輸出線，如圖4.2.3.為例，第一行[‘Start0’, ‘ExtremePoint’, [ ], [‘line_0’]]，表示我有一功能塊名稱為Start0，它是ExtremePoint模組， 輸入線為[ ]，表示沒有輸入線，輸出線則是line_0。 實作流程範例如圖4.2.3，圖例表達為一個testMode的功能塊的動作循環執行五次， 轉換成DSL如圖4.2.3左，以此種設置方式若對List中的個功能塊List之間任意調換順序仍 可正確，只要連結線無誤，程式會依據起使功能塊Start開始索引，依照連結線名稱索引 跳至下一指定功能塊執行動作，直至到功能塊End結束流程程式。 這些DSL指令List，傳至DSL Framework，將從功能塊Start開始索引一個起使目標， 依據它輸出線的名稱索引有同樣名稱輸入線的功能塊，到至該行功能塊List進行會如執 行它的模組動作結束後，同樣的動作，依據它輸出線的名稱索引有同樣名稱輸入線的功 能塊，如果是Decision或Loop時，則模組內部會依當前的流程傳遞的輸入值與Decision或 Loop設定的條件，進行邏輯判斷，判別當下情況該走哪一條分枝輸出線，以上步驟直至 功能塊End結束流程程式，執行DSL指令List前，會先將其經由Debugger初步檢查，讓使 用者能先排除錯誤，如此可以避免，可能設計一資料模擬迭代，迭代了數千或數十萬次， 才執行到剛好有錯誤的流程部分，浪費極多時間與效率。 格式 ‘BlockName+ RandomNum’ ‘ModuleName’ [輸入線名稱 list] [輸出線名 稱list] [其他附加條件] ‘Start+ RandomNum’ ‘ExtremePoint’ (內建名稱) [ ] [輸出線名 稱] ‘End+ RandomNum’ ‘ExtremePoint’ (內建名稱) [輸入線名稱 list] [ ] ‘Mode+ RandomNum’ ‘DefinedModuleNa me’ (自建名稱) [輸入線名稱 list] [輸出線名 稱] [[欲修改的變數 1,值], [欲修改 的變數2, 值],…[] ] ‘Decision+ RandomNum’ ‘Decide’ (內建名稱) [輸入線名稱 list] [True輸出 線名 稱,False輸 出線名稱] [‘比較參數’, ‘operator’, ‘數值’] ‘Loop+ RandomNum’ ‘Loop’ (內建名稱) [輸入線名稱 list] [End輸出 線名稱, continue 輸出線名 稱] [‘比較參數’, ‘operator’, ‘數值’], Counter次數 ‘Loop+ RandomNum +break’ ‘Loop’ (內建名稱) [輸入線名稱] [輸出線名 稱] 表4.2.3  DSL規則格式 圖4.2.3  DSL範例示意圖
