MasonPy 提供設計流程圖方式的DSL，設計實作已建置基本功能塊Start、End、 Process、Decision、Loop，它在基本的流程運行中所需要的功能與使用上所需的條件要 素，也已內建建構完成，提供直接的使用。 剩下僅需DSL developer 給予它靈魂——自定義的功能塊，在這項可自定義的功能 塊設計的目的是專門提供DSL developer，將其領域所需要的資料處理、科學運算、演算 法設計……等，可能需要的功能或是需要重複性使用的動作，加以設計包成功能塊，建 構出其領域所需之DSL。 4.3.1如何撰寫功能塊的DSL MasonPy先創建一基本Process功能塊，先將基本上可能會用到的功能建置在其中， 如圖4.3.1.a，以及一些簡易的格式檢測以確保符合格式能使MasonPy的流程正確進行， 使用者僅需如圖4.3.1.b範例，對已建構好的基本Process進行繼承，依據設計情況將變數、 公式、功能塊文字敘述、執行動作……等，設置依據格式放入相對應的method中，即可 設計一個新的功能塊完成。 自定義功能塊 基本設置功能如下:  參數初始化  參數修改  公式設定  執行功能塊動作  功能塊文字敘述設定  檢查連結線是否有連結至目標物  檢查連結線是否有連結至目標物  檢查是否已有連結線  提取自身或其他功能塊內部變數與值 以一簡單範例說明設計，如圖4.3.1.b設計一個海龍公式功能塊，由三角形輸入三邊長 求面積，建立一個新的class繼承於Process，將使用說明敘述設定、參數設定、公式設定、 執行動作設定，等對照Process的設計，對應如圖4.3.1.a，即可簡單的設計完成，實作結 合GUI的呈現如圖4.3.1.c，我們可從點擊功能塊的說明鍵，即跳出說明視窗，再點擊功能 塊編輯鍵，即跳出參數出入視窗，可針對進行修改，Process的功能塊的設計有提供提取 功能塊內部的變數與值的功能銜接至GUI，可以輕鬆的實踐圖4.3.1.c中那變數欄，呈現 變數與值的關係。 1. from numpy import* 2. 3. class originalMode(object): 4.     def __init__(self, name = '', lastMode = None, inputLines=[], outputLines='', us erSetVals=[]): 5.         self.setintro()                # 設定功能塊說明敘述 6. 7.         self.name = name               # 功能塊名稱 8.         self.lastMode = lastMode       # 前次功能塊 9. 10.         self.inputLines = inputLines   # 輸入線List 11.         self.outputLines = outputLines # 輸出線List 12. 13.         self.AllVariables = []         # 參數設定 14.         self.setInit()                 # 其他初始化動作 15. 16.         self.SetVals(userSetVals)      # 修改預設參數 17. 18.     # 設定功能塊說明敘述 19.     def setintro(self): 20.         info = '自定義功能塊\n' 21.         info = info + '可經由簡易的參數與公式設定建立自定義功能塊\n' 22.         self.intro_str = info 23.         return self.intro_str 24. 25.     # 輸始化設定 26.     def setInit(self): 27.         self.setInitValue() 28.         pass 29. 30.     # 變數初始化 31.     def setInitValue(self, *parameters):  # parameter = [variable, value]  self.vari able=value 32.         for i in range(len(parameters[0])): 33.             self.AllVariables.append(str(parameters[0][i][0])) 34.             exec( 'self.' + str(parameters[0][i][0]) +'='+ str(parameters[0][i][1])) 35. 36.     # 變數修改 37.     def SetVals(self, userSetVals=[]): 38.         if len(userSetVals) > 0: 39.             for i in range(len(userSetVals)): 40.                 exec('self.'+str(userSetVals[i][0])+'='+str(userSetVals[i][1])) 41. 42.     # 執行功能塊 43.     def do(self): 44.         pass 45. 46.     # 連結線檢查是否連結 47.     def isConnect(self): 48.         connectLine = self.lastMode.outputLines 49.         if connectLine in self.inputLines: 50.             return True 51.         else: 52.             msg = 'Not connected !' 53.             return  msg 54. 55.     # 連結目標是否為有效功能塊 56.     def checkConnect(self, lastMode): 57.         if isinstance(lastMode, originalMode): 58.             if lastMode.outputLines in self.inputLines: 59.                 return True 60.             else: 61.                 msg = 'Can not connect !' 62.                 return  msg 63.         else: 64.             msg = 'Type of input is error !' 65.             return msg 66. 67.     # 讀取物件中屬性的值 68.     def getValue(self, obj, string): 69.         if  str(string) in dir(obj): 70.             value = eval('self.'+string) 71.             return value 72.         else: 73.             msg = 'The parameter is not in object !' 74.             return msg 圖4.3.1.a  Process 程式碼 1. from BasicModule.Mode import* 2. from math import* 3. 4. class HeronFormula(originalMode): 5. 6.     def setintro(self): 7.         info = '海龍公式\n' 8.         info = info + '三角形三邊長(A、B、C),求三角形面積Area=? \n' 9.         info = info + 'S = (A+B+C)/2 \n' 10.         info = info + 'Area = √(s(s−a)(s−b)(s−c)) \n' 11.         self.intro_str = info 12. 13.     def setInit(self): 14.         self.setInitValue([['A', 5], ['B', 12], ['C',13],['Area',None]]) 15. 16.     def do(self): 17.         self.CalArea() 18. 19.     def CalArea(self): 20.         S = (self.A+self.B+self.C)/2 21.         if self.A <= 0 or self.B <= 0 or self.C <= 0: 22.             self.Area = None 23.         else: 24.             self.Area = sqrt(S*(S-self.A)*(S-self.B)*(S-self.C)) 圖4.3.1.b  範例設計程式碼(海龍公式) 圖4.3.1.c  GUI操作(海龍公式) 4.3.2如何匯入功能塊 setModule檔案中抓取整個Project中.py檔的路徑，再經由比對欲匯入的DSL(功能塊) 的class名稱後，將功能塊匯入以提供使用者使用，故DSL developer可以將欲匯入功能塊 在setModule檔案中將功能塊名稱設置完畢，功能塊區即跟著更新，如此可以避免全部匯 入，造成中間產物或是暫不需要的模組也匯入，匯入這些並不需要使用的功能塊模組， 使得浪費資源，且也讓功能塊區選項繁雜，造成使用者的不便，如圖4.3，領域專家可能 建構了Domain1、Domain2、Domain3，此時只需要用Domain1，則只需在setModule設定 Domain1功能塊名稱，則其他Domain則不會匯入，功能塊區也僅有Domain1的功能塊， 如此一來功能塊區只會出現需要用的功能塊，降低了繁雜的可能，也不會像一定要放入 指定資料夾後才能匯入，或檔案複製、搬動可能造成的錯誤。 圖4.3  匯入檔案設定示意圖
